<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <title>{{ data.question }}</title>
</head>

<body style="background-color:powderblue;">
    <div class="container">
        <div class="card-group">
            <div class="card">
                <form action="/" method="POST" onsubmit="return captureForm()">
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
                    <div class="card-body">
                        <h2 class="card-title">{{ data.question }}</h2>
                    </div>
                    <ul class="list-group list-group-flush">
                        <div class="card-header">Candidates</div>
                        {% for e in data.fields %}
                        <li class="list-group-item">
                            <div class="radio">
                                <label>
                                    <input class="candidate" type="radio" name="field" value="{{ e }}"> {{ e }}<br>
                                </label>
                            </div>
                        </li>
                        {% endfor %}
                    </ul>
                    <div class="card-body">
                        <button type="submit" class="btn btn-primary">Vote</button>
                    </div>
                    <div class="card-footer text-muted">
                        {{ stats.nvotes }} votes so far
                    </div>
                </form>
            </div>
            <div class="card">
                <div class="card-body">
                    <h2 class="card-title">About</h2>
                    <p class="card-text"> Demo election web interface using the <a
                            href="https://github.com/kth-tcs/verificatum-vjsc/">Verificatum JavaScript Cryptographic
                            library</a> for client-side encryption.</p>
                    <p class="card-text">Encryption must be done with a provided public key which is produced by the <a
                            href="https://www.verificatum.org/">Verificatum</a> mix network.</p>
                    <p class="card-text">When the &quot;submit&quot; button is pressed, the form&#39;s data is modified
                        and the
                        currently selected option is encrypted using the public key and some randomness. The web
                        server is then unable to decrypt the vote. Instead, the mix network that produced the public
                        key must jointly decrypt and shuffle the collected votes.</p>
                </div>
                <div class="card-footer text-muted">
                    Made for the <a href="https://www.trustfull.proj.kth.se/">Trustfull project</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.WASM_PATH = "{{url_for('static', filename='optimized.wasm')}}"
    </script>
    <script src="{{url_for('static', filename='min-vjsc-1.1.1.js')}}"></script>
    <script>
        function captureForm() {
            for (const candidate of document.getElementsByClassName('candidate')) {
                if (candidate.checked) {
                    var found = false;
                    {% for e in data.fields %}
                    found |= candidate.value === "{{ e }}";
                    {% endfor %}
                    if (!found) {
                        console.error("Candidate does not much any expected value");
                        return false;
                    }

                    candidate.value = encrypt(candidate.value);
                    return true;
                }
            }

            console.error('No candidate selected');
            return false;
        }

        function encrypt(s) {
            function initRandomSource() {
                const randomSource = new verificatum.crypto.RandomDevice();
                const seed = randomSource.getBytes(verificatum.crypto.SHA256PRG.seedLength);
                const ret = new verificatum.crypto.SHA256PRG();
                ret.setSeed(seed);
                return ret;
            }

            var randomSource = initRandomSource();

            var WIDTH = 1;  // Depends on vmni configuration

            // TODO: Read 'PublicKey' file which is saved as a "raw" ByteTree
            var bt = verificatum.eio.ByteTree.readByteTreeFromByteArray({{ data.publicKey }});

            console.assert(verificatum.util.byteArrayToAscii(bt.value[0].value[0].value).endsWith('ECqPGroup'));
            var keyPGroup = verificatum.arithm.ECqPGroup.fromByteTree(bt.value[0].value[1]);
            var fullPublicKey = new verificatum.arithm.PPGroup(keyPGroup, 2).toElement(bt.value[1]);
            var eg = new verificatum.crypto.ElGamal(true, keyPGroup, randomSource, 20);
            var wpk = eg.widePublicKey(fullPublicKey, WIDTH);

            // Encode message
            var ascii_bytes = s.split('').map(x => x.charCodeAt(0));  // TODO: do it with verificatum utils
            var encoded = wpk.pGroup.project(1).encode(ascii_bytes);
            var encrypted = eg.encrypt(wpk, encoded);

            // XXX: why?
            var encrypted0 = encrypted.values[0].toByteTree().toByteArray();
            var encrypted1 = encrypted.values[1].toByteTree().toByteArray();
            return JSON.stringify([encrypted0, encrypted1]);
            // return JSON.stringify(encrypted.toByteTree().toByteArray());
        }
    </script>

</body>

</html>
